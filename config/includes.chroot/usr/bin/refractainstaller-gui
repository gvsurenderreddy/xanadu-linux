#!/usr/bin/env bash
version="Refracta Installer 9.0.9beta6 (20131206)"
# Copyright 2011, 2012, 2013 fsmithred@gmail.com
# Based on refractainstaller-8.0.3 by Dean Linkous
# License: GPL-3
# This is free software with NO WARRANTY. Use at your own risk!

# If you want to change any defaults, change them in the configfile.
# Default is /etc/refractainstaller.conf
# If you want to use a different config file for testing, change this
# variable. Normally, users should not edit anything in this script.



configfile="/etc/refractainstaller.conf"

if [[ -f $configfile ]]; then
    source $configfile
else
	zenity --error --title=Error --text="  Config file $configfile is missing. "
	echo " Config file $configfile is missing."
	exit 1
fi

# Record errors in a logfile.
exec 2>"$error_log"


show_help () {
	printf "$help_text"
	exit 0
}

help_text="
	Usage:  $0  [option]
	
	Run refractainstaller-gui from a terminal with no options  
	or select Refracta Installer from the System menu to install 
	a running live-CD or live-usb-hdd to a hard drive. 
	
	
	valid options:
		-h, --help		show this help text
		-v, --version	display the version information
		-d, --debug		debug mode
"

while [[ $1 == -* ]]; do
	case "$1" in
	
		-h|--help)
			show_help ;;
		
		-v|--version)
			printf "\n$version\n\n" 
			exit 0 ;;
			
		-d|--debug)
			DEBUG="yes"
			break ;;
				
		*) 
			printf "\t invalid option: $1 \n\n"
			printf "\t Try:  $0 -h for full help. \n\n"
			exit 1 ;;
    esac
done		


if [[ $DEBUG = "yes" ]] ; then
	set -x
fi


# Check that xserver is running and user is root.
[[ $DISPLAY ]] || { echo "There is no xserver running. Exiting..." ; exit 1 ; }
if [[ $(id -u) -ne 0 ]] ; then
	zenity --error --text="You need to be root! "
	exit 1
fi


# function to exit the script if there are errors
check_exit () {
if [[ $? -ne 0 ]] ; then
	zenity --error --text="Exit due to error: $?
See $error_log for details." &
	exit 1
fi
}


copy_excludes () {
        cat > "$rsync_excludes" <<EOF
# It is safe to delete this file after installation.

- /dev/*
- /cdrom/*
- /media/*
- /target
- /swapfile
- /mnt/*
- /sys/*
- /proc/*
- /tmp/*
- /live
- /boot/grub/grub.cfg
- /boot/grub/menu.lst
- /boot/grub/device.map
- /etc/udev/rules.d/70-persistent-cd.rules
- /etc/udev/rules.d/70-persistent-net.rules
- /etc/fstab
- /etc/fstab.d
- /etc/mtab
- /home/snapshot/
- /home/*/.gvfs

# Added for newer version of live-config/live-boot
# in sid (to become Jessie)
- /lib/live/overlay
- /lib/live/image
- /lib/live/rootfs
- /lib/live/mount
- /run/*

EOF
    check_exit
    chmod 666 "$rsync_excludes"
}


if ! [[ -d /lib/live/mount/medium ]] ; then
	live_session_warning=" ###	WARNING: Not running from live-CD or live-USB	### 
 ###	or unsupported configuration. Be sure you know	### 
 ###	what you are doing. This may not work.			### "
fi


# Ask if user wants Simple Install or Expert Install
choose_simple_expert () {
install=$(zenity --list --title="Installation Mode" \
     --text="$live_session_warning
     
 This utility will install a running live-CD or live-USB to your hard drive.

 This is free software that comes with no warranty or guarantee of any 
 type, including but not limited to express, implied, merchantability or 
 fitness of purpose. 

 Copyright 2011-2013 fsmithred@gmail.com, 
 based on refractainstaller-8.0.3 by Dean Linkous. 
" \
     --radiolist --column "Choose" --column "Num" --column "Option" \
     --width=520 --height=165 --cancel-label=Exit \
  FALSE 01 "Simple installation (one partition, few questions.)" \
  FALSE 02 "Expert install (more options)")
	if [[ $? = 1 ]] ; then
		exit 0
	fi  
if $(echo $install | grep -q 01); then
    install="simple"
fi
if $(echo $install | grep -q 02); then
    install="expert"
fi
if [[ -z $install ]] ; then
	choose_simple_expert
fi
}

choose_simple_expert





# Check that rsync excludes file exists, or create one.
if [[ $install = "expert" ]]; then
    if ! [[ -f  $rsync_excludes ]] ; then
        zenity --question --ok-label=Continue --cancel-label=Exit \
        --text="There is no rsync excludes file, or its name does not match what this script expects. You should let the script create one, or if you have a custom excludes file, and you know what you're doing, you can exit the script and edit the rsync_excludes variable at the top so that it matches the name and path of your custom file.
    
If you have any other drives or partitions mounted that you don't want to be copied, unmount them or edit the excludes file to list them."
        if [[ $? = 0 ]] ; then
			rsync_excludes="$(pwd)/installer_exclude.list"
            copy_excludes
        else
            exit 0
        fi
    fi
else
	rsync_excludes="$(pwd)/installer_exclude.list"
    copy_excludes
fi


# These set the default setting in the options window,
# based on setting in config file. Simple Install does
# what config file says, Expert allows you to change it.
if [[ $run_preinstall = "yes" ]] ; then
	var16="TRUE"
else
	var16="FALSE"
fi
if [[ $run_postinstall = "yes" ]] ; then
	var17="TRUE"
else
	var17="FALSE"
fi

pre_install_list=$(ls -m /usr/lib/refractainstaller/pre-install)
post_install_list=$(ls -m /usr/lib/refractainstaller/post-install)


# Select expert installation options
if [[ $install = "expert" ]]; then
    opts=$(zenity --list --title="Installation Options" \
     --text="Check the options you want for the installation.
If you don't understand an option, you probably don't need it." \
     --checklist --column "Choose" --column "Num" --column "Option" \
     --width=590 --height=535 --ok-label=OK --cancel-label=Exit \
  FALSE 01 "Change user name" \
  FALSE 02 "Create a separate /home partition" \
  FALSE 03 "Create a separate /boot partition" \
  FALSE 04 "Use existing swap partition instead of swapfile." \
  FALSE 05 "Encrypt the root filesystem (separate /boot required)" \
  FALSE 06 "Encrypt the /home partition (separate /home required)" \
  FALSE 07 "Write random data to encrypted partitions (more secure)" \
  FALSE 08 "Write zeroes to all partitions (to erase previous data)" \
  FALSE 09 "Do not install bootloader. I'll handle it myself." \
  FALSE	10 "Do not format filesystems. I'll handle it myself." \
  FALSE 11 "Use UUID in /etc/fstab. (Useful if drive order changes.)" \
  FALSE 12 "Use filesystem labels (disk labels) in /etc/fstab." \
  FALSE 13 "Change hostname." \
  FALSE 14 "Disable automatic login to desktop." \
  FALSE 15 "Disable automatic login to console. (Use stock Debian inittab)" \
  $var16 16 "Run pre-install scripts (listed below)
$pre_install_list" \
  $var17 17 "Run post-install scripts (listed below)
$post_install_list")

fi
	if [[ $? = 1 ]] ; then
		exit 0
	fi

if $(echo $opts | grep -q 01); then 
    change_user="yes"
fi
if $(echo $opts | grep -q 02); then
    sep_home="yes"
fi
if $(echo $opts | grep -q 03); then
    sep_boot="yes"
fi
if $(echo $opts | grep -q 04); then
    use_existing_swap="yes"
fi
if $(echo $opts | grep -q 05); then
    encrypt_os="yes"
fi
if $(echo $opts | grep -q 06); then
    encrypt_home="yes"
fi
if $(echo $opts | grep -q 07); then
    write_random="yes"
fi
if $(echo $opts | grep -q 08); then
    write_zero="yes"               
fi
if $(echo $opts | grep -q 09); then
    bootloader="no"
else
    bootloader="yes"
fi
if $(echo $opts | grep -q 10); then
	if [[ $encrypt_os = "yes" ]] || [[ $encrypt_home = "yes" ]]; then
		no_format=""
	else
		no_format="yes"
	fi
fi
if $(echo $opts | grep -q 1); then
	if [[ $encrypt_os = "yes" ]] || [[ $encrypt_home = "yes" ]]; then
		uuid_message="--> UUIDs in fstab won't work with encrypted filesystems and
 will not be used. Edit fstab manually after the installation."
	else
		use_uuid="yes"
	fi
fi
if $(echo $opts |grep -q 12); then
	if [[ $encrypt_os = "yes" ]] || [[ $encrypt_home = "yes" ]]; then
		disklabel_message="--> Disk labels in fstab won't work with encrypted filesystems and
 will not be used. Edit fstab manually after the installation."
	elif [[ $use_uuid = "yes" ]]; then
		disklabel_message="--> This script can't do both UUIDs and disk labels for fstab.
 UUIDs will be used, and you can add disk labels manually, after the install."
	else
		use_labels="yes"
		disklabel_message="You will be given a chance to create disk labels."
	fi
fi
if $(echo $opts | grep -q 13); then
	change_hostname="yes"
fi
if $(echo $opts | grep -q 14); then
	disable_auto_desktop="yes"
fi
if $(echo $opts | grep -q 15); then
	disable_auto_console="yes"
fi
if $(echo $opts | grep -q 16); then
	run_preinstall="yes"
else
	run_preinstall="no"
fi
if $(echo $opts | grep -q 17); then
	run_postinstall="yes"
else
	run_postinstall="no"
fi


if [[ $encrypt_os = "yes" ]] || [[ $encrypt_home = "yes" ]]; then
    # test for cryptsetup
    if ! [[ -f /sbin/cryptsetup ]] ; then
        zenity --question --title=Error \
         --ok-label="Proceed without encrypting partitions" \
         --cancel-label=Exit --text="You need to install cryptsetup and run the command, 'sudo modprobe dm-mod' before you can use encryption."
        if [[ $? = 0 ]] ;  then
            encrypt_os="no"
            encrypt_home="no"
        else
            exit 1
        fi
    fi
    # end test for cryptsetup
fi    







partitioning_method () {
## Partition a disk ##### Simple install now does get to partition the disk - uncomment the conditional below to change it back.
#if [[ $install = "expert" ]]; then
    partitioner=$(zenity --list --title=Partitioning --ok-label=Yes --cancel-label=No \
		--text="You need to have at least one partition ready for the installation, plus one for 
each separate partition that you chose." \
		--radiolist --column "Choose"   --column "Option" \
		--width=420 --height=210 --cancel-label=Exit \
  FALSE "Run GParted partitioner now." \
  FALSE "Run cfdisk partitioner in a terminal." \
  FALSE "No thanks, I already have a partition prepared. Continue." )
#  FALSE "I'd like to exit the script now.") 
	if [[ $? = 1 ]] ; then
		exit 0
	fi

	if $(echo $partitioner | grep -q GParted) ; then
		gparted
		check_exit
	fi
	if $(echo $partitioner | grep -q cfdisk) ; then
		xterm  -fa monaco -fs 12 -geometry 90x20+0+0 -hold -e cfdisk
	fi
	if [[ -z $partitioner ]] ; then
		partitioning_method
	fi

#	if $(echo $partitioner | grep -q exit) ; then
#		exit 0
#	fi
}

partitioning_method

#    # test to make sure there's a separate /boot partition
if [[ $sep_boot = "no" ]]; then
    if [[ $encrypt_os = "yes" ]]; then
        zenity --question --title=Error \
         --ok-label="Proceed without encrypting partition" \
         --cancel-label=Exit --text="You MUST have a separate, unencrypted /boot partition if you intend to boot an encrypted operating system. You can proceed without encrypting the root filesystem, or you can exit and start over."
        if [[ $? = 0 ]] ;  then
            encrypt_os="no"
        else
            exit 1
        fi
    fi
fi



no_grub () {
		zenity --question --ok-label="Yes, I'm sure." --cancel-label="Go back." --title="Bootloader" \
		--text="$grub_warning_message"
		if [[ $? = 1 ]]; then
			choose_grub
		fi
}
# Choose a place for grub: MBR, partition or none. If none selected, give warning.
choose_grub () {
opt=$(zenity --list --title="Install GRUB bootloader" \
  --text="Choose a location to install the GRUB bootloader. The usual choice 
is to put it in the master boot record of the first hard drive (/dev/sda).
" \
  --radiolist --column ' ' --column 'Hard Drives' --separator="" \
  --height=210 --cancel-label="Exit" \
  FALSE "Install GRUB to MBR of any hard disk." \
  FALSE "Install GRUB to a partition." \
  FALSE	"Proceed without a bootloader.")
	if [[ $? = 1 ]] ; then
		exit 0
	fi

if [[ $opt =~ MBR ]] ; then
	grub_dev=$(find /dev -mindepth 1 -maxdepth 1  -name "*[sh]d[a-z]" \
  | sort | awk '{print "\n" $0 }' \
  | zenity --list --radiolist --separator="" --title="Bootloader" --text="Choose a hard disk for the bootloader.
" \
  --column ' ' --column 'Hard Drives' --height=200)
  echo $grub_dev
	if [[ -z $grub_dev ]]; then
		grub_warning_message="You did not select a drive. No bootloader will be installed. \nAre you sure you want this?"
		no_grub
		return
	fi
fi

if [[ $opt =~ partition ]] ; then
	grub_partition=$(find /dev -mindepth 1 -maxdepth 1  -name "*[sh]d[a-z][1-9]*" \
  | sort | awk '{print "\n" $0 }' \
  | zenity --list --radiolist  --title="Bootloader" --text="Select a partition for the bootloader (GRUB)." \
  --separator="" --column ' ' --column 'Partitions' --height=380 --width=150)
  echo $grub_partition
	if [[ -z $grub_partition ]]; then
		grub_warning_message="You did not select a partition. No bootloader will be installed. \nAre you sure you want this?"
		no_grub
		return
	fi
fi

if [[ $opt =~ Proceed ]] ; then
		grub_warning_message="No bootloader will be installed. Are you sure you want this?"
		no_grub
		return
fi

if [[ -z $opt ]]; then
	grub_warning_message="No bootloader will be installed. Are you sure you want this?"
	no_grub
	return
fi
}



# determine grub version now, it gets used for installing the bootloader and
# preventing simple install from using ext4 with grub-legacy or grub-gfx.
	grubversion=$(dpkg -l | egrep "ii|hi" | grep -v bin | grep -v doc | awk '$2 ~ "grub-[glp]" { print $2}')
#	grubversion="grub-legacy"   # for testing, comment out the above line and uncomment this one

### Simple install gets default grub bootloader in /dev/sda
if [[ $install = "expert" ]]; then
    if [[ $bootloader = "yes" ]]; then
        choose_grub
    fi
fi

if [[ $install = "simple" ]]; then
    grub_dev="/dev/sda"
fi

# Show output of blkid for reference.
#xterm  -fa monaco -fs 12 -geometry 90x20+0+0 -hold -e 'echo "Partition list (for reference.)  You may need this later." && blkid -c /dev/null' &
blkid -c /dev/null | zenity --text-info --title="Partition List" --text="Partition list (for reference.)  You may need this later." \
--width 820 --height 400 &
sleep 2

# Show the partition list in a menu, and choose one for /boot
choose_boot () {
boot_dev=$(find /dev -mindepth 1 -maxdepth 1  -name "*[sh]d[a-z][1-9]*" \
  | sort | awk '{print "FALSE\n" $0 }' \
  | zenity --list --title="/boot partition" --text="Select a partition for /boot." \
 --radiolist --multiple --column ' ' --column 'Partitions' --height=380 --width=150 --cancel-label=Exit)
	if [[ $? = 1 ]] ; then
		exit 0
	fi
}

if [[ $sep_boot = "yes" ]]; then
    choose_boot
fi


# Choose filesystem type for /boot
choose_fs_boot () {
if [[ -n $boot_dev ]]; then
     fs_type_boot=$(zenity --list --title="/boot filesystem" --text="What type of filesystem would you like on $boot_dev?" \
  --radiolist --column "Choose" --column "Format" --height=200\
  FALSE "ext2" \
  FALSE "ext3" \
  FALSE "ext4")
fi

if [[ -z $fs_type_boot ]]; then
    zenity --question --title=Error --ok-label="Go back" --cancel-label=Exit \
      --text="You must choose a file system type for /boot"
    if [[ $? = 0 ]]; then
        choose_fs_boot
    else
        exit 1
    fi
fi
}

if [[ -n $boot_dev ]]; then
	if [[ $no_format = "yes" ]]; then 
		fs_type_boot=$(blkid -s TYPE "$boot_dev" | awk -F"\"" '{ print $2 }')
	else
		choose_fs_boot
	fi
fi



# Show the partition list in a menu, and choose one for the OS
choose_root () {
install_dev=$(find /dev -mindepth 1 -maxdepth 1  -name "*[sh]d[a-z][1-9]*" \
  | sort | awk '{print "FALSE\n" $0 }' \
  | zenity --list --title="Root Partition" --text="Choose a partition to use for the installation of the operating system." \
--radiolist --multiple --column ' ' --column 'Partitions' --height 380 --width 150 --cancel-label=Exit)
	if [[ $? = 1 ]] ; then
		exit 0
	fi

if [[ -z $install_dev ]] ; then
    zenity --question  --title=Error --ok-label="Go back" --cancel-label="Exit" \
  --text="Nothing was selected. You must select a partition for the installation. What would you like to do?"
        if [[ $? = 0 ]] ; then
            choose_root
        else
            exit 1
        fi
elif ! [[ -b $install_dev ]] ; then
    zenity --question --title=Error --ok-label="Go back" --cancel-label="Exit" \
  --text="    Something is wrong. Maybe you checked
    more than one box. You said you want to install
    the system to $install_dev"
        if [[ $? = 0 ]] ; then
            choose_root
        else
            exit 1
        fi
elif
    [[ $install_dev = $boot_dev ]] ; then
    zenity --info --title=Error --text="You chose the same partition for the operating system as the one for /boot. Try again."
        choose_root
fi
}

choose_root


# Choose filesystem type for OS.
choose_fs_os () {
fs_type_os=$(zenity --list --title="Root Filesystem" --text="What type of filesystem would you like on $install_dev?" \
  --radiolist --column "Choose" --column "Format" --height=200\
  FALSE "ext2" \
  FALSE "ext3" \
  FALSE "ext4")
if [[ -z $fs_type_os ]]; then
    zenity --question --ok-label="Go back" --cancel-label=Exit \
      --text="You must choose a file system type
for the operating system"
    if [[ $? = 0 ]]; then
        choose_fs_os
    else
        exit 1
    fi
fi  
}


### Simple install gets default ext4 filesystem (or ext3 with older grub)
if [[ $install = "expert" ]]; then
	if [[ $no_format = "yes" ]]; then 
		fs_type_os=$(blkid -s TYPE "$install_dev" | awk -F"\"" '{ print $2 }')
	else
		choose_fs_os
	fi
else
    if [[ $grubversion = "grub-pc" ]] ; then
        fs_type_os="ext4"
    else
		fs_type_os="ext3"
	fi
fi



# Show the partition list in a menu, and choose one for /home
choose_home () {
home_dev=$(find /dev -mindepth 1 -maxdepth 1  -name "*[sh]d[a-z][1-9]*" \
  | sort | awk '{print "FALSE\n" $0 }' \
  | zenity --list --title="/home partition" --text="Select a partition for /home" \
--radiolist --multiple --column ' ' --column 'Partitions' --height=380 --width=150 --cancel-label=Exit)
	if [[ $? = 1 ]] ; then
		exit 0
	fi
if [[ -n $home_dev ]] ; then
    if ! [[ -b $home_dev ]] ; then
        zenity --question  --ok-label="Go back" --cancel-label=Exit \
        --text="    Something is wrong. Maybe you checked
    more than one box. You said you want to install
    the system to $home_dev"
        if [[ $? = 0 ]] ; then
            choose_home
        else
            exit 1
        fi
    elif
        [[ $install_dev = $home_dev ]] ; then
        zenity --info --title=Error --text="You chose the same partition for /home as the one for the operating system. If you don't want a separate /home partition, then click OK without selecting one."
        choose_home
    elif
        [[ $boot_dev = $home_dev ]] ; then
        zenity --info --title=Error --text="You chose the same partition for /home as the one for /boot. Try again."
        choose_home
    fi
fi
}

if [[ $sep_home = "yes" ]]; then
    choose_home
fi

# Choose filesystem type for /home
choose_fs_home () {
if [[ -n $home_dev ]]; then
     fs_type_home=$(zenity --list --title="/home filesystem" --text="What type of filesystem would you like on $home_dev?" \
  --radiolist --column "Choose" --column "Format" --height=200\
  FALSE "ext2" \
  FALSE "ext3" \
  FALSE "ext4")
fi

if [[ -z $fs_type_home ]]; then
    zenity --question --title=Error --ok-label="Go back" --cancel-label=Exit \
      --text="You must choose a file system type for /home"
    if [[ $? = 0 ]]; then
        choose_fs_home
    else
        exit 1
    fi
fi
}

if [[ -n $home_dev ]]; then
	if [[ $no_format = "yes" ]]; then 
		fs_type_home=$(blkid -s TYPE "$home_dev" | awk -F"\"" '{ print $2 }')
	else
		choose_fs_home
	fi
fi


# Show the partition list in a menu, and choose one for swap
choose_swap () {
swap_info=$(/sbin/blkid |grep swap | awk '{print "\n" $0 }'\
| zenity --list --radiolist  --title="swap partition" --text="Select a partition for swap." \
  --separator="" --column ' ' --column 'Partitions' --height=180 --width=500)
swap_dev=$(echo $swap_info | awk -F: '{ print $1 }')
if [[ -z $swap_dev ]] ; then
	zenity --window-icon=error --title=Error --text="You did not choose a swap partition.
Click OK to use a swapfile instead.
Click Cancel to exit the program."
        if [[ $? = 0 ]] ; then
            use_existing_swap=""
        else
            exit 1
        fi
fi
}

if [[ $use_existing_swap = "yes" ]]; then
    choose_swap
fi



# Enter new hostname (or use the old hostname as the new one)
# Test to make sure it's a legal hostname, and let user fix it
# if it's not.
fix_hostname () {
	new_hostname=$(zenity --entry --title="Change hostname" \
	--text="Illegal hostname. Try again.
	
You can use alphanumeric characters anywhere in the hostname, and 
you can use the minus sign (-) as long as it's not at the beginning or end." \
	--entry-text="$HOSTNAME")
	test_hostname	
}

test_hostname () {
	if [[ $new_hostname =~ [_]|[@]|[~]|[\!]|[\#]|[=]|[+]|[\&]|[\^]|[\$]|[%]|[\(]|[\)]|[\*]|[\:]|[\;]|[\"]|[\']|[\`]|[,]|[.]|[\<]|[\>]|[\?]|[\{]|[\}]|[\[]|[\]]|[/]|[\|]|[\ ] ]]; then
 		fix_hostname
	elif [[ $new_hostname = -* ]] || [[ $new_hostname = *- ]]; then
		fix_hostname
	elif [[ -z $new_hostname ]]; then
		new_hostname="$HOSTNAME"
	fi
}

select_hostname () {
	new_hostname=$(zenity --entry --title="Change hostname" \
	--text="Enter new hostname for installed system." \
	--entry-text="$HOSTNAME")
	new_hostname="$HOSTNAME"
}


if [[ $change_hostname = "yes" ]]; then
	select_hostname
else
	new_hostname="$HOSTNAME"
fi


# Show a summary of what will be done
if [[ $change_user = "yes" ]]; then
    user_message="--> User name will be changed."
fi

if [[ -n $grub_dev ]] ; then
    grub_dev_message="--> Bootloader will be installed in $grub_dev"
elif [[ -n $grub_partition ]] ; then
	grub_dev_message="--> Bootloader will be installed in $grub_partition"
else
    grub_dev_message="--> Bootloader will not be installed."
fi

if [[ $encrypt_os = yes ]] ; then
    os_enc_message=", and will be encrypted."
fi

if [[ -z $home_dev ]] ; then
    home_dev_message="--> /home will not be on a separate partition."
elif
	[[ $no_format = "yes" ]]; then
		home_dev_message="--> /home will be installed on $home_dev"
else
    home_dev_message="--> /home will be installed on $home_dev and formatted as $fs_type_home"
fi

if [[ -n $home_dev ]] && [[ $encrypt_home = yes ]] ; then
    home_enc_message=", and will be encrypted."
fi

if [[ -n $boot_dev ]] ; then
	if [[ $no_format != "yes" ]]; then
		boot_dev_message="--> /boot will be installed on $boot_dev and formatted as $fs_type_boot."
	else
		boot_dev_message="--> /boot will be installed on $boot_dev"
	fi
fi

if [[ $encrypt_os = yes ]] || [[ $encrypt_home = yes ]] ; then
    proceed_message="***  IF YOU PROCEED, YOU WILL NEED TO RESPOND TO SOME QUESTIONS IN THE TERMINAL.   Be prepared to create passphrases for any encrypted partitions (several times each.) When you see the progress bar come up, you can take a break."
fi

if [[ $disable_auto_desktop = "yes" ]]; then
	desktop_message="Desktop autologin will be disabled."
fi

if [[ $disable_auto_console = "yes" ]]; then
	console_message="Console autologin will be disabled."
fi

if [[ $no_format = "yes" ]]; then
	install_dev_message="--> Operating system will be installed on $install_dev, and you will (or did) format it manually."
else
	install_dev_message="--> Operating system will be installed on $install_dev and formatted as $fs_type_os$os_enc_message"
fi

if [[ $run_preinstall = "yes" ]] ; then
	preinstall_message="pre-install scripts are enabled."
else
	preinstall_message="pre-install scripts are disabled."	
fi
if [[ $run_postinstall = "yes" ]] ; then
	postinstall_message="post-install scripts are enabled."
else
	postinstall_message="post-install scripts are disabled."	
fi


zenity --question --title=Summary --ok-label="Proceed with the installation." --cancel-label="Exit" \
    --text="Please CLOSE any running applications NOW.

Here is a summary of what will be done. THIS IS YOUR LAST CHANCE TO EXIT before any changes are made to the disk.

$grub_dev_message
$install_dev_message$os_enc_message
$home_dev_message$home_enc_message
$boot_dev_message
$user_message
$desktop_message
$console_message
$uuid_message
$disklabel_message
Hostname: $new_hostname
$preinstall_message
$postinstall_message
  
$proceed_message"
    if [[ $? != 0 ]] ; then
        exit 0
    fi


# Actual installation begins here


# Run pre-install scripts if enabled.
if [[ $run_preinstall = "yes" ]] ; then
	for file in /usr/lib/refractainstaller/pre-install/* ; do
		if [[ -x $file ]] ; then
			bash $file
		fi
	done
fi



# Unmount or close anything that might need unmounting or closing
cleanup () {
if $(df | grep -q /target/proc/) ; then
    umount /target/proc/
fi

if $(df | grep -q /target/dev/) ; then
    umount /target/dev/
fi

if $(df | grep -q /target/sys/) ; then
    umount /target/sys/
fi

# grep gives an error if $boot_dev is null
if $(df | grep -q $boot_dev) ; then
    umount $boot_dev
fi

if $(df | grep -q /target_boot) ; then
    umount -l /target_boot/
fi

if $(df | grep -q /target_home) ; then
    umount -l /target_home/
fi

# grep gives an error if $home is null
if $(df | grep -q $home_dev) ; then
    umount $home_dev
fi

if $(df | grep -q "\/dev\/mapper\/home_fs") ; then
    umount /dev/mapper/home_fs
fi

if [[ -h /dev/mapper/home_fs ]] ; then
    cryptsetup luksClose home_fs
fi

if $(df | grep -q /target) ; then
    umount -l /target/
fi

if $(df | grep -q $install_dev) ; then
    umount $install_dev
fi    

if $(df | grep "\/dev\/mapper\/root_fs") ; then
    umount /dev/mapper/root_fs
fi

if [[ -h /dev/mapper/root_fs ]] ; then
    cryptsetup luksClose /dev/mapper/root_fs
fi


# These next ones might be unnecessary
if [[ -d /target ]] ; then
    rm -rf /target
fi

if [[ -d /target_home ]] ; then
    rm -rf /target_home
fi

if [[ -d /target_boot ]] ; then
    rm -rf /target_boot
fi
}

cleanup


# Write random data to OS partition
if [[ $write_random = "yes" ]]; then
    if [[ $encrypt_os = "yes" ]]; then
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e dd if=/dev/urandom of="$install_dev"
#       # Redirect stderr so we can see the output of dd
		exec 2>&1
        dd if=/dev/urandom of="$install_dev"
#       # Resume logging errors in file
        exec 2>>"$error_log"
    fi  
fi

# Write random data to /home partition
if [[ $write_random = "yes" ]]; then
    if [[ $encrypt_home = "yes" ]]; then
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e dd if=/dev/urandom of="$home_dev"
#       # Redirect stderr so we can see the output of dd
		exec 2>&1
        dd if=/dev/urandom of="$home_dev"
#       # Resume logging errors in file
        exec 2>>"$error_log"
    fi  
fi


# Write zeros to partitions
if [[ $write_zero = "yes" ]]; then
#       # Redirect stderr so we can see the output of dd
		exec 2>&1
    #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e dd if=/dev/zero of="$install_dev"
    dd if=/dev/zero of="$install_dev"
    if [[ $sep_home = "yes" ]]; then
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e dd if=/dev/zero of="$home_dev"
        dd if=/dev/zero of="$home_dev"
    fi
    if [[ $sep_boot = "yes" ]]; then
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e dd if=/dev/zero of="$boot_dev"
        dd if=/dev/zero of="$boot_dev"
    fi
#       # Resume logging errors in file
        exec 2>>"$error_log"
fi


# make mount point, format, adjust reserve and mount
# install_dev must maintain the device name for cryptsetup
# install_part will be either device name or /dev/mapper name as needed.
mkdir /target ;  check_exit
if [[ $encrypt_os = yes ]] ; then
    #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e cryptsetup luksFormat "$install_dev" ; check_exit
    #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e cryptsetup luksOpen "$install_dev" root_fs ; check_exit
    cryptsetup luksFormat "$install_dev" ; check_exit
    cryptsetup luksOpen "$install_dev" root_fs ; check_exit
    install_part="/dev/mapper/root_fs"
else
    install_part="$install_dev"
fi 
if [[ $no_format != "yes" ]]; then
	mke2fs -t $fs_type_os "$install_part" ; check_exit 
	tune2fs -r 10000 "$install_part" ; check_exit
fi
mount "$install_part" /target ; check_exit 


# make mount point for separate home if needed
# and add /home/* to the excludes list if it's not already there
if [[ -n $home_dev ]] ; then
    mkdir /target_home ; check_exit
    if [[ $encrypt_home = yes ]]; then
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e cryptsetup luksFormat "$home_dev"
        cryptsetup luksFormat "$home_dev"
        check_exit
        #xterm -fa monaco -fs 12 -geometry 80x20+0+0 -e cryptsetup luksOpen "$home_dev" home_fs
        cryptsetup luksOpen "$home_dev" home_fs
        check_exit
        home_part="/dev/mapper/home_fs"
    else
        home_part=$home_dev
	fi
	if [[ $no_format != "yes" ]]; then
	    mke2fs -t $fs_type_home "$home_part" ; check_exit
	    tune2fs -r 10000 "$home_part" ; check_exit
	fi
    mount "$home_part" /target_home ; check_exit
	sep_home_opt="--exclude=/home/*"
fi


# make mount point for separate /boot if needed
# and add /boot/* to the excludes list if it's not already there
# allow default for reserved blocks (don't need tune2fs here)
if [[ -n $boot_dev ]] ; then
    mkdir /target_boot ; check_exit
    if [[ $no_format != "yes" ]]; then
		mke2fs -t $fs_type_boot $boot_dev ; check_exit
	fi
    mount $boot_dev /target_boot
    sep_boot_opt="--exclude=/boot/*"
fi

# copy everything over except the things listed in the exclude list
rsync -av / /target/ --exclude-from="$rsync_excludes" ${sep_home_opt} ${sep_boot_opt} | \
tee >(zenity --progress --pulsate --auto-close \
 --text="Copying system to new partition.")
check_exit 

# copy separate /home if needed
if ! [[ -z $home_dev ]] ; then
	rsync -av /home/ /target_home/ --exclude-from="$home_boot_excludes" | \
    tee >(zenity --progress --pulsate --auto-close \
     --text="Copying home folders to new partition.")
    check_exit
fi

# copy separate /boot if needed
if [[ -n $boot_dev ]] ; then
    rsync -av /boot/ /target_boot/ --exclude-from="$home_boot_excludes" ; check_exit | \
    tee >(zenity --progress --pulsate --auto-close \
     --text="Copying files to boot partition.")
    check_exit
fi


# create swapfile
if ! [[ $use_existing_swap = "yes" ]] ; then
	dd if=/dev/zero of=/target/swapfile bs="$swapfile_blocksize" count="$swapfile_count" | \
	tee >(zenity --progress --pulsate --width=350 --auto-close --title="Making a swap file...")
	mkswap /target/swapfile ; check_exit 
fi


# copy the real update-initramfs back in place
if [[ -f /target/usr/sbin/update-initramfs.distrib ]] ; then
    cp /target/usr/sbin/update-initramfs.distrib /target/usr/sbin/update-initramfs
fi
if [[ -f /target/usr/sbin/update-initramfs.debian ]] ; then
    cp /target/usr/sbin/update-initramfs.debian /target/usr/sbin/update-initramfs
fi


# Disallow mounting of all fixed drives with pmount
if [[ -f /target/etc/pmount.allow ]] ; then
	if [[ $pmount_fixed = "no" ]] ; then
		sed -i 's:/dev/sd\[a-z\]:#/dev/sd\[a-z\]:' /target/etc/pmount.allow
	fi
fi

# Re-enable updatedb if it was disabled by an older version of refractasnapshot
if [[ -e /target/usr/bin/updatedb.mlocate ]] ; then
	if ! [[ -x /target/usr/bin/updatedb.mlocate ]] ; then
		chmod +x /target/usr/bin/updatedb.mlocate
	fi
fi


# Disable autologin to desktop
if [[ $disable_auto_desktop = "yes" ]]; then

	#gdm
    if [[ -f /target/etc/gdm/gdm.conf ]]; then
        sed -i 's/^AutomaticLogin/#AutomaticLogin/' /target/etc/gdm/gdm.conf
    fi

	#gdm3
    if [[ -f /target/etc/gdm3/daemon.conf ]]; then
        sed -i 's/^AutomaticLogin/#AutomaticLogin/' /target/etc/gdm3/daemon.conf
    fi

	#lightdm
	if [[ -f /target/etc/lightdm/lightdm.conf ]]; then
		sed -i 's/^autologin/#autologin/g' /target/etc/lightdm/lightdm.conf
	fi

	#kdm
	if [ -f /target/etc/default/kdm.d/live-autologin ]; then
	rm -f /target/etc/default/kdm.d/live-autologin
	fi

	if [ -f /target/etc/kde3/kdm/kdmrc ]; then
	sed -i -e 's/^AutoLogin/#AutoLogin/g' /target/etc/kde3/kdm/kdmrc
	sed -i -e 's/^AutoReLogin/#AutoReLogin/g' /target/etc/kde3/kdm/kdmrc
	fi

	if [ -f /target/etc/kde4/kdm/kdmrc ]; then
	sed -i -e 's/^AutoLogin/#AutoLogin/g' /target/etc/kde4/kdm/kdmrc
	sed -i -e 's/^AutoReLogin/#AutoReLogin/g' /target/etc/kde4/kdm/kdmrc
	fi

	#trinity
	if [[ -f /target/etc/default/kdm-trinity.d/live-autologin ]]; then
		sed -i 's/^AUTOLOGIN/#AUTOLOGIN/g' /target/etc/default/kdm-trinity.d/live-autologin
	fi
	
	if [ -f /target/etc/trinity/kdm/kdmrc ]; then
	sed -i -e 's/^AutoLogin/#AutoLogin/g' /target/etc/trinity/kdm/kdmrc
	sed -i -e 's/^AutoReLogin/#AutoReLogin/g' /target/etc/trinity/kdm/kdmrc
	fi
fi

# Disable console autologin
if [[ $disable_auto_console = "yes" ]]; then
	if grep -q "respawn:/bin/login -f" /target/etc/inittab ; then
		mv /target/etc/inittab /target/etc/inittab.$(date +%Y%m%d_%H%M)
		cp /usr/lib/refractainstaller/inittab.debian /target/etc/inittab
	fi
fi


# Change hostname
if [[ $new_hostname != $HOSTNAME ]]; then
		sed -i "s/$HOSTNAME/$new_hostname/" /target/etc/hostname
		sed -i "s/$HOSTNAME/$new_hostname/g" /target/etc/hosts
fi


# setup fstab

# add entry for root filesystem
if [[ $encrypt_os != "yes" ]]; then
	if [[ $use_uuid = yes ]]; then
		install_part="$(blkid -s UUID $install_dev | awk '{ print $2 }' | sed 's/\"//g')"
	elif [[ $use_labels = yes ]]; then
			rootfslabel=$(/sbin/blkid -c /dev/null -s LABEL $install_dev | awk -F"\"" '{ print $2 }')
			if [[ -n $rootfslabel ]]; then
				install_part="LABEL=$rootfslabel"
			else
				rootfslabel=$(zenity  --entry --title="Filesystem Label"  --text="Enter a disk label for $install_dev")
				if [[ -n $rootfslabel ]]; then
					e2label "$install_dev"  "$rootfslabel"
					install_part="LABEL=$rootfslabel"
				else
					install_part="$install_dev"
				fi
			fi
	else
		install_part="$install_dev"
	fi
fi
echo -e "proc\t\t/proc\tproc\tdefaults\t0\t0
$install_part\t/\t$fs_type_os\tdefaults,noatime\t0\t1" >> /target/etc/fstab
check_exit


# add entry for /home to fstab if needed
if ! [[ -z $home_dev ]] ; then
	if [[ $encrypt_home != "yes" ]]; then
		if [[ $use_uuid = yes ]]; then
			home_part="$(blkid -s UUID $home_dev | awk '{ print $2 }' | sed 's/\"//g')"
		elif [[ $use_labels = yes ]]; then
				homefslabel=$(/sbin/blkid -c /dev/null -s LABEL $home_dev | awk -F"\"" '{ print $2 }')
				if [[ -n $homefslabel ]]; then
					home_part="LABEL=$homefslabel"
				else
					homefslabel=$(zenity  --entry --title="Filesystem Label"  --text="Enter a disk label for $home_dev")
					if [[ -n $homefslabel ]]; then
						e2label "$home_dev"  "$homefslabel"
						home_part="LABEL=$homefslabel"
					else
						home_part="$home_dev"
					fi
				fi
		else
			home_part="$home_dev"
	fi
fi    
    echo -e "$home_part\t/home\t$fs_type_home\tdefaults,noatime\t0\t2" >> /target/etc/fstab
    check_exit
fi

# add entry for /boot to fstab if needed
if [[ -n $boot_dev ]] ; then
	if [[ $use_uuid = yes ]]; then
		boot_part="$(blkid -s UUID $boot_dev | awk '{ print $2 }' | sed 's/\"//g')"
	elif [[ $use_labels = yes ]]; then
			bootfslabel=$(/sbin/blkid -c /dev/null -s LABEL $boot_dev | awk -F"\"" '{ print $2 }')
			if [[ -n $bootfslabel ]]; then
				boot_part="LABEL=$bootfslabel"
			else
				bootfslabel=$(zenity  --entry --title="Filesystem Label"  --text="Enter a disk label for $boot_dev")
				if [[ -n $bootfslabel ]]; then
					e2label "$boot_dev"  "$bootfslabel"
					boot_part="LABEL=$bootfslabel"
				else
					boot_part="$boot_dev"
				fi
			fi
	else
		boot_part="$boot_dev"
	fi
    echo -e "$boot_part\t/boot\t$fs_type_boot\tdefaults,noatime,\t0\t2" >> /target/etc/fstab
    check_exit
fi


# add entry for swap to fstab if needed
if [[ $use_existing_swap = "yes" ]] ; then
	if [[ $use_uuid = yes ]]; then
		swap_part="$(/sbin/blkid -s UUID $swap_dev | awk '{ print $2 }' | sed 's/\"//g')"
	else
		swap_part="$swap_dev"
	fi
    echo -e "\n Adding swap entry to fstab...\n"
    echo -e "$swap_part\tswap\tswap\tdefaults\t0\t0" >> /target/etc/fstab
elif ! [[ $use_existing_swap = "yes" ]] ; then
	echo -e "/swapfile\tswap\tswap\tdefaults\t0\t0" >> /target/etc/fstab
fi


# Add entry for root filesystem to crypttab if needed
if [[ $encrypt_os = yes ]] ; then
    echo -e "root_fs\t\t$install_dev\t\tnone\t\tluks" >> /target/etc/crypttab
fi


# Add entry for /home to crypttab if needed
if [[ $encrypt_home = yes ]] ; then
    echo -e "home_fs\t\t$home_dev\t\tnone\t\tluks" >> /target/etc/crypttab
fi


# mount stuff so grub will behave (so chroot will work)
mount -t tmpfs --bind /dev/ /target/dev/ ; check_exit 
mount -t proc --bind /proc/ /target/proc/ ; check_exit 
mount -t sysfs --bind /sys/ /target/sys/ ; check_exit 


# Re-enable freshclam if it was disabled by snapshot 		##### This ain't perfect, but it works!
if type -p freshclam ; then
	if [[ $enable_freshclam = "yes" ]] ; then
		if ! [[ -h /target/etc/rc2.d/S02clamav-freshclam ]] ; then
			chroot /target update-rc.d clamav-freshclam defaults
		fi
	fi
fi


# Disable root login through ssh for the installed system
if [[ -f /etc/ssh/sshd_config ]] ; then
	if [[ $root_ssh = "no" ]] ; then
		sed -i~ 's/PermitRootLogin yes/PermitRootLogin no/' /target/etc/ssh/sshd_config
	fi
fi


# Setup GRUB 


# If /boot is separate partition, need to mount it in chroot for grub
if [[ -n $boot_dev ]] ; then
    chroot /target mount $boot_dev /boot
fi


# If grub is installed to a partition, we need to know if it's grub-pc
# or grub-legacy/grub-gfx to handle it properly.
if [[ -n $grub_partition ]] ; then
	if [[ $grubversion != "grub-pc" ]] ; then

		# isolate the device (sdx) letter then use tr like this to translate to the right number for grub
		GRUBDEVICENUM=$(echo $grub_partition |sed 's:/dev/sd::' |sed 's:[0-9]::'g |tr '[a-j]' '[0-9]')

		# isolate the partition number
		INSTALLPARTNUM=$(echo $grub_partition |sed 's:/dev/sd::'|sed 's:[a-z]::')

		# and reduce it by 1 for grub
		GRUBPARTNUM=$(expr $INSTALLPARTNUM - 1)

		# finally get the finished grub root syntax
		GRUBROOT="(hd$GRUBDEVICENUM,$GRUBPARTNUM)"


		chroot /target /bin/bash grub-install $grub_partition
		grub --batch <<EOF
		root $GRUBROOT
		setup $GRUBROOT
		quit
EOF

	else
		error_message="grub-install failed."
		chroot /target /bin/bash grub-install --recheck --no-floppy --force $grub_partition >> "$error_log" ; check_exit
	fi
fi


if [[ -n $grub_dev ]]; then
    echo -e "\n Installing the boot loader...\n" >> "$error_log"
    error_message="grub-install failed."
    chroot /target grub-install $grub_dev >> "$error_log" ; check_exit
fi

error_message=""


# Run update-initramfs to include dm-mod if using encryption
if [[ $encrypt_os = yes ]] || [[ $encrypt_home = yes ]] ; then
    chroot /target /usr/sbin/update-initramfs.orig.initramfs-tools -u >> "$error_log"
fi

if [[ -n $grub_dev ]] || [[ -n $grub_partition ]] ; then
    chroot /target update-grub ; check_exit 
fi


# INSTALLATION FINISHED - BEGIN CHANGE USERNAME

# Need to mount the target home partition under the target root partition
# so the commands can find it (for changing user configs gksu)
if [[ $sep_home = "yes" ]]; then
    mount $home_part /target/home
fi


# Change the username   ### Change PRIMARY user's name - define $oldname
# even if not changing name, and use it for gksu below #################################
if [[ $change_user = "yes" ]]; then
	oldname=$(awk -F: '/1000:1000/ { print $1 }' /target/etc/passwd)
	newname=$(zenity --entry --title="Change login name" --text="The primary user's current login name is $oldname. 
Enter the new login name you want to use.")


	chroot /target usermod -l $newname $oldname ; check_exit
	chroot /target groupmod -n $newname $oldname ; check_exit
	chroot /target usermod -d /home/$newname -m $newname ; check_exit

	for i in $(grep -r "/home/$oldname" /target/home/$newname/.config | awk -F":" '{ print $1 }'); do
		sed -i "s/\/home\/$oldname/\/home\/$newname/g" "$i"
	done

	for i in $(grep -r "/home/$oldname" /target/home/$newname/.local | awk -F":" '{ print $1 }'); do
		sed -i "s/\/home\/$oldname/\/home\/$newname/g" "$i"
	done
fi

#### Add user's real name in /etc/passwd (for Refracta)
if [[ $change_user = "yes" ]]; then
    live_user=$(awk -v pattern="$newname" -F: '$1 ~ pattern { print $5 }' /target/etc/passwd)
    real_name=$(zenity --entry --title="Change real name" --text="The user's real name is currently $live_user.
Enter the real name you want to use \(without 
the trailing commas\).")
    sed -i~ "s/$live_user/$real_name,,,/" /target/etc/passwd
fi


# Edit /etc/sudoers
#if [[ $install = "expert" ]]; then
#    zenity --question --title="Edit /etc/sudoers" --ok-label=Yes --cancel-label=No \
#     --text="You may need to edit /etc/sudoers to comment out the line that gives $oldname absolute power, 
#or replace $oldname with $newname. A simple text-editor will open in the terminal if you do this now.

#Edit /etc/sudoers now?"
#    if [[ $? = 0 ]]; then
#        edit_sudoers="yes"
#        #xterm  -fa monaco -fs 12 -geometry 80x20+0+0 -e chroot /target visudo
#		chroot /target visudo    
#	fi
#fi


# Disable sudo-mode for gksu
#if [[ $edit_sudoers = "yes" ]]; then
#    zenity --question --title="Disable sudo mode for gksu" --ok-label="Yes, I commented out the line." --cancel-label="No, I replaced the old name with the new one." \
#     --text="If you commented out the line in /etc/sudoers in the last step, one more file will be changed for you so that gksu will work properly."
#        if [[ $? = 0 ]]; then
#            if [[ -n $newname ]]; then
#                sed -i~ '/sudo-mode/s/true/false/' /target/home/"$newname"/.gconf/apps/gksu/%gconf.xml
#            else
#                sed -i~ '/sudo-mode/s/true/false/' /target/home/user/.gconf/apps/gksu/%gconf.xml
#            fi
#        fi
#fi



# Change/create root password
if [[ $install = "expert" ]]; then
    zenity --question --title="Change/create root password" --ok-label=Yes --cancel-label=No \
     --text="
Would you like to change the root password? (Recommended)
You'll need to go to the terminal again...

Note: If your system has no root user, and you want 
to keep it that way, say No. " 
        if [[ $? = 0 ]]; then
            #xterm  -fa monaco -fs 12 -geometry 80x20+0+0 -e chroot /target passwd
#       # Redirect stderr so we can see the output of dd
		exec 2>&1
            chroot /target passwd
#       # Resume logging errors in file
        exec 2>>"$error_log"
        fi 
fi


# Change user password
if [[ $change_user = "yes" ]]; then
    zenity --question --title="Change user password" --ok-label=Yes --cancel-label=No \
     --text="Would you like to change the user's password? The new user still has the old user's password. You'll need to go to the terminal again to do this."
        if [[ $? = 0 ]]; then
            #xterm  -fa monaco -fs 12 -geometry 80x20+0+0 -e chroot /target passwd "$newname"
#       # Redirect stderr so we can see the output of dd
		exec 2>&1
			chroot /target passwd "$newname"       
#       # Resume logging errors in file
        exec 2>>"$error_log"
		fi
fi


# Run post-install scripts if enabled.
if [[ $run_postinstall = "yes" ]] ; then
	for file in /usr/lib/refractainstaller/post-install/* ; do
		if [[ -x "$file" ]] ; then
			bash "$file"
		fi
	done
fi


# copy error log to installation before calling cleanup function
cp "$error_log" /target/var/log/
cleanup


zenity --info --text="Done!\n\n You may now reboot into the new system.\n\nRemember to remove your installation media.\n"

exit 0
